import os
import re
import json
import boto3
import datetime
from urllib.parse import unquote_plus
from botocore.config import Config
from botocore.exceptions import ClientError

# ---------- ENV ----------
REGION = os.getenv("REGION", "ap-south-1")
TABLE_NAME = os.getenv("TABLE_NAME", "structure-data")
MODEL_ID = os.getenv("MODEL_ID", "amazon.titan-text-express-v1")
MAX_CHARS = int(os.getenv("MAX_CHARS", "8000"))

# Optional for manual/cron triggers
SRC_BUCKET = os.getenv("SRC_BUCKET")          # e.g. source-bucket
SRC_PREFIX = os.getenv("SRC_PREFIX", "")      # e.g. incoming/

# ---------- AWS clients ----------
s3 = boto3.client("s3", region_name=REGION)
dynamodb = boto3.resource("dynamodb", region_name=REGION)
bedrock = boto3.client(
    "bedrock-runtime",
    region_name=REGION,
    config=Config(connect_timeout=5, read_timeout=60, retries={"max_attempts": 3, "mode": "standard"})
)
table = dynamodb.Table(TABLE_NAME)

# ---------- Helpers ----------
def _read_s3_text(bucket: str, key: str) -> str:
    obj = s3.get_object(Bucket=bucket, Key=key)
    raw = obj["Body"].read()
    try:
        text = raw.decode("utf-8")
    except UnicodeDecodeError:
        text = raw.decode("latin-1", errors="ignore")

    if key.lower().endswith(".json"):
        try:
            js = json.loads(text)
            extracted = []
            def walk(v):
                if isinstance(v, dict):
                    for vv in v.values(): walk(vv)
                elif isinstance(v, list):
                    for vv in v: walk(vv)
                elif isinstance(v, (str, int, float)):
                    extracted.append(str(v))
            walk(js)
            merged = "\n".join(extracted)
            return merged if len(merged) > 20 else text
        except Exception:
            pass
    return text

def _prompt_for_schema(doc_text: str) -> str:
    doc_sample = doc_text[:MAX_CHARS]
    return f"""
Return ONLY strict JSON (no explanations/markdown/backticks). Use exactly:
{{
  "docType": "invoice | resume | bank_statement | id_card | receipt | others",
  "schema": {{
    "fields": {{ "<field_name>": "<value as string>" }},
    "confidence": 0.0
  }}
}}
Rules:
- Infer docType from content.
- Use sensible fields:
  - resume: name, email, phone, skills, total_experience_years, latest_company, latest_title, education
  - invoice: invoice_number, invoice_date, vendor, bill_to, total_amount, currency, line_items
  - bank_statement: account_number, account_holder, statement_period, opening_balance, closing_balance
  - receipt: merchant, date, total_amount, payment_method
- Values must be strings only. If unsure, docType="others" but still extract best-effort fields.
- Avoid hallucinations; only output fields present in the text.
- First character MUST be '{{' and last MUST be '}}'.

Document Text:
{doc_sample}
""".strip()

def _safe_json_parse_from_model(text: str) -> dict | None:
    if not text:
        return None
    s = text.strip()
    s = re.sub(r"^```(?:json)?\s*|\s*```$", "", s, flags=re.MULTILINE)
    m = re.search(r"\{.*\}", s, flags=re.DOTALL)
    if not m:
        return None
    candidate = m.group(0)
    candidate = re.sub(r",\s*([}\]])", r"\1", candidate)  # remove trailing commas
    try:
        return json.loads(candidate)
    except Exception as e:
        print({"json_parse_error": str(e), "snippet": candidate[:500]})
        return None

def _call_bedrock_json(prompt: str) -> dict:
    def _converse(p: str) -> str:
        resp = bedrock.converse(
            modelId=MODEL_ID,
            messages=[{"role": "user", "content": [{"text": p}]}],
            inferenceConfig={"maxTokens": 1200, "temperature": 0, "topP": 1},
        )
        parts = resp.get("output", {}).get("message", {}).get("content", [])
        return "".join(p.get("text", "") for p in parts if "text" in p)

    try:
        text_out = _converse(prompt)
        parsed = _safe_json_parse_from_model(text_out)
        if parsed:
            return parsed

        retry_prompt = (
            "Return ONLY a valid JSON object for the previous task. "
            "No commentary, no text, no markdown. Start with '{' and end with '}'."
        )
        text_out2 = _converse(retry_prompt)
        parsed2 = _safe_json_parse_from_model(text_out2)
        if parsed2:
            return parsed2
        print({"warn": "unparseable_after_retry", "sample": (text_out2 or text_out)[:300]})
    except Exception as e:
        print({"bedrock_converse_error": str(e)})

    return {"docType": "others", "schema": {"fields": {}, "confidence": 0.0}}

def _stringify_fields(d: dict) -> dict:
    out = {}
    for k, v in (d or {}).items():
        if isinstance(v, (dict, list)):
            out[k] = json.dumps(v, separators=(",", ":"), default=str)
        else:
            out[k] = "" if v is None else str(v)
    return out

EMAIL_RE = re.compile(r"[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}")
PHONE_RE = re.compile(r"(?:\+?\d[\s-]?)?(?:\(?\d{3,4}\)?[\s-]?)?\d{3,4}[\s-]?\d{4,5}")
NAME_HINT_RE = re.compile(r"^[A-Z][a-z]+(?: [A-Z][a-z]+){0,3}$")

def _fallback_extract(doc_text: str, hint: str) -> tuple[str, dict]:
    lt = doc_text.lower()
    if hint == "resume" or "resume" in lt or "curriculum vitae" in lt:
        fields = {}
        email = EMAIL_RE.search(doc_text)
        phone = PHONE_RE.search(doc_text)
        if email: fields["email"] = email.group(0)
        if phone: fields["phone"] = phone.group(0)
        for line in doc_text.splitlines():
            line = line.strip()
            if 2 <= len(line) <= 60 and NAME_HINT_RE.match(line):
                fields["name"] = line
                break
        return "resume", fields
    if hint == "invoice" or "invoice" in lt:
        fields = {}
        m = re.search(r"(invoice\s*(no\.?|#)\s*[:\-]?\s*)([A-Za-z0-9\-_/]+)", doc_text, re.I)
        if m: fields["invoice_number"] = m.group(3)
        d = re.search(r"(invoice\s*date\s*[:\-]?\s*)([0-9]{1,2}[\/\-\s][A-Za-z0-9]{1,3}[\/\-\s][0-9]{2,4})", doc_text, re.I)
        if d: fields["invoice_date"] = d.group(2)
        tot = re.search(r"(total|amount due)\s*[:\-]?\s*([₹$€]?\s?\d[\d,]*\.?\d*)", doc_text, re.I)
        if tot: fields["total_amount"] = tot.group(2)
        vend = re.search(r"(vendor|from)\s*[:\-]?\s*([A-Za-z0-9 &.,\-]+)", doc_text, re.I)
        if vend: fields["vendor"] = vend.group(2).strip()
        return "invoice", fields
    if hint == "bank_statement" or ("debit" in lt and "credit" in lt and "balance" in lt):
        fields = {}
        acc = re.search(r"(account\s*number|a\/c\s*no\.?)\s*[:\-]?\s*([A-Za-z0-9\- ]+)", doc_text, re.I)
        if acc: fields["account_number"] = acc.group(2).strip()
        per = re.search(r"(statement\s*period|period)\s*[:\-]?\s*([A-Za-z0-9\-\s/]+)", doc_text, re.I)
        if per: fields["statement_period"] = per.group(2).strip()
        return "bank_statement", fields
    return "others", {}

def _put_dynamo(document_id: str, doc_type: str, data_fields: dict):
    item = {
        "documentId": document_id,
        "docType": doc_type or "others",
        "data": data_fields or {},
        "createdAt": datetime.datetime.utcnow().isoformat() + "Z",
    }
    table.put_item(Item=item)
    return item

# -------- latest-object selection helpers --------
def _head_last_modified(bucket: str, key: str):
    h = s3.head_object(Bucket=bucket, Key=key)
    return h["LastModified"], h.get("VersionId")

def _choose_latest_from_event(records):
    latest = None
    for r in records:
        b = r["s3"]["bucket"]["name"]
        k = unquote_plus(r["s3"]["object"]["key"])
        try:
            lm, vid = _head_last_modified(b, k)
        except ClientError as e:
            print({"warn": "head_failed", "bucket": b, "key": k, "err": str(e)})
            continue
        info = {"bucket": b, "key": k, "last_modified": lm, "version_id": vid}
        if (latest is None) or (info["last_modified"] > latest["last_modified"]):
            latest = info
    return latest

def _get_latest_object(bucket: str, prefix: str = ""):
    paginator = s3.get_paginator("list_objects_v2")
    latest = None
    for page in paginator.paginate(Bucket=bucket, Prefix=prefix):
        for obj in page.get("Contents", []):
            if (latest is None) or (obj["LastModified"] > latest["LastModified"]):
                latest = obj
    if latest:
        return {"bucket": bucket, "key": latest["Key"], "last_modified": latest["LastModified"]}
    return None

# ---------- Handler ----------
def lambda_handler(event, context):
    print("Received event:", json.dumps(event))

    # CASE A: S3 event trigger — pick the newest object in the batch
    if event.get("Records"):
        latest = _choose_latest_from_event(event["Records"])
        if not latest:
            return {"status": "skipped", "reason": "no valid records"}
        bucket = latest["bucket"]
        key = latest["key"]
    else:
        # CASE B: Manual / scheduled trigger — pick newest under prefix
        if not SRC_BUCKET:
            return {"status": "skipped", "reason": "no Records and no SRC_BUCKET set"}
        found = _get_latest_object(SRC_BUCKET, SRC_PREFIX)
        if not found:
            return {"status": "skipped", "reason": "no objects under prefix"}
        bucket = found["bucket"]
        key = found["key"]

    # Only .txt/.json inputs (your extraction step writes these)
    if not (key.lower().endswith(".txt") or key.lower().endswith(".json")):
        print(f"Skipping non-text/json key: {key}")
        return {"status": "skipped", "key": key}

    # 1) Read doc text
    text_content = _read_s3_text(bucket, key)
    if not text_content or not text_content.strip():
        raise ValueError(f"No text content read from s3://{bucket}/{key}")

    # 2) Doc-type hint
    lower = text_content.lower()
    doc_hint = ""
    if any(k in lower for k in ["curriculum vitae", "resume", "objective", "skills", "experience", "education"]):
        doc_hint = "resume"
    elif any(k in lower for k in ["invoice", "subtotal", "gst", "bill to", "invoice #", "tax invoice"]):
        doc_hint = "invoice"
    elif any(k in lower for k in ["account number", "closing balance", "debit", "credit", "statement period"]):
        doc_hint = "bank_statement"

    # 3) Bedrock call
    base_prompt = _prompt_for_schema(text_content)
    prompt = f"(DocType hint: {doc_hint})\n{base_prompt}" if doc_hint else base_prompt
    result = _call_bedrock_json(prompt)

    # 4) Extract fields
    doc_type = (result or {}).get("docType", "others")
    schema = result.get("schema", {}) if isinstance(result, dict) else {}
    fields = schema.get("fields", {}) if isinstance(schema, dict) else {}

    if not fields:
        fb_doc, fb_fields = _fallback_extract(text_content, doc_hint)
        if fb_fields:
            if doc_type == "others":
                doc_type = fb_doc
            fields = fb_fields

    # 5) Ensure Dynamo-safe strings
    fields = _stringify_fields(fields)

    # 6) Write to DynamoDB
    s3_uri = f"s3://{bucket}/{key}"
    item = _put_dynamo(s3_uri, doc_type, fields)

    print("Stored item:", json.dumps(item))
    return {"status": "done", "documentId": s3_uri, "docType": doc_type, "fieldsCount": len(fields)}
